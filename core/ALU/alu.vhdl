-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
entity COMP_GATE_SIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_SIGNED;

architecture Behavioral of COMP_GATE_SIGNED is
begin
  process(a, b)
  begin
    if (signed(a) > signed(b)) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (signed(a) < signed(b)) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_1 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic;
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_1;

architecture Behavioral of MUX_GATE_BUS_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Add is
  generic ( Bits: integer ); 
  port (
    s: out std_logic_vector((Bits-1) downto 0);
    c_o: out std_logic;
    a: in std_logic_vector((Bits-1) downto 0);
    b: in std_logic_vector((Bits-1) downto 0);
    c_i: in std_logic );
end DIG_Add;

architecture Behavioral of DIG_Add is
   signal temp : std_logic_vector(Bits downto 0);
begin
   temp <= ('0' & a) + b + c_i;

   s    <= temp((Bits-1) downto 0);
   c_o  <= temp(Bits);
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity ripple_carry_adder_overflow is
  port (
    A: in std_logic_vector(15 downto 0);
    B: in std_logic_vector(15 downto 0);
    C_in: in std_logic;
    Q: out std_logic_vector(15 downto 0);
    C_out: out std_logic;
    V: out std_logic);
end ripple_carry_adder_overflow;

architecture Behavioral of ripple_carry_adder_overflow is
  signal s0: std_logic_vector(14 downto 0);
  signal s1: std_logic_vector(14 downto 0);
  signal s2: std_logic_vector(14 downto 0);
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal C_out_temp: std_logic;
begin
  s0 <= A(14 downto 0);
  s4 <= A(15);
  s1 <= B(14 downto 0);
  s5 <= B(15);
  gate0: entity work.DIG_Add
    generic map (
      Bits => 15)
    port map (
      a => s0,
      b => s1,
      c_i => C_in,
      s => s2,
      c_o => s3);
  gate1: entity work.DIG_Add
    generic map (
      Bits => 1)
    port map (
      a => s4,
      b => s5,
      c_i => s3,
      s => s6,
      c_o => C_out_temp);
  Q(14 downto 0) <= s2;
  Q(15) <= s6;
  V <= (C_out_temp XOR s3);
  C_out <= C_out_temp;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_2 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (1 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_2;

architecture Behavioral of MUX_GATE_BUS_2 is
begin
  with sel select
    p_out <=
      in_0 when "00",
      in_1 when "01",
      in_2 when "10",
      in_3 when "11",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_1 is
  port (
    p_out: out std_logic;
    sel: in std_logic;
    
    in_0: in std_logic;
    in_1: in std_logic );
end MUX_GATE_1;

architecture Behavioral of MUX_GATE_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    A: in std_logic_vector(15 downto 0); -- First input to ALU
    B: in std_logic_vector(15 downto 0); -- Second input to ALU
    ALUOP: in std_logic_vector(1 downto 0); -- Operation selection input
    RESULT: out std_logic_vector(15 downto 0); -- The result of this ALU operation
    FLAG: out std_logic_vector(3 downto 0) -- The flags associated with the result of this ALU operation
                                           -- 
                                           -- 0. Z (zero)
                                           -- 1. N (negative)
                                           -- 2. C (carry)
                                           -- 3. V (overflow)
    );
end main;

architecture Behavioral of main is
  signal RESULT_temp: std_logic_vector(15 downto 0);
  signal s0: std_logic_vector(15 downto 0);
  signal s1: std_logic;
  signal s2: std_logic_vector(15 downto 0);
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic_vector(15 downto 0);
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic;
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
  signal C_out: std_logic;
  signal V: std_logic;
begin
  s0 <= NOT B;
  gate0: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 2)
    port map (
      a => "01",
      b => ALUOP,
      eq => s1);
  s10 <= ALUOP(1);
  gate1: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s1,
      in_0 => B,
      in_1 => s0,
      p_out => s2);
  s3 <= (A OR s2);
  s5 <= (A AND s2);
  gate2: entity work.ripple_carry_adder_overflow
    port map (
      A => A,
      B => s2,
      C_in => s1,
      Q => s4,
      C_out => C_out,
      V => V);
  gate3: entity work.MUX_GATE_BUS_2
    generic map (
      Bits => 16)
    port map (
      sel => ALUOP,
      in_0 => s4,
      in_1 => s4,
      in_2 => s5,
      in_3 => s3,
      p_out => RESULT_temp);
  gate4: entity work.MUX_GATE_1
    port map (
      sel => s10,
      in_0 => C_out,
      in_1 => '0',
      p_out => s8);
  gate5: entity work.MUX_GATE_1
    port map (
      sel => s10,
      in_0 => V,
      in_1 => '0',
      p_out => s9);
  gate6: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => RESULT_temp,
      b => "0000000000000000",
      eq => s6,
      le => s7);
  FLAG(0) <= s6;
  FLAG(1) <= s7;
  FLAG(2) <= s8;
  FLAG(3) <= s9;
  RESULT <= RESULT_temp;
end Behavioral;
